/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package wireguard-go-bridge */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
extern size_t _GoStringLen(_GoString_ s);
extern const char *_GoStringPtr(_GoString_ s);
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 15 "bridge_allowedips.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"

#line 15 "bridge_cookie.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"

#line 15 "bridge_crypto.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"

#line 15 "bridge_device.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"

#line 15 "bridge_keys.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"

#line 15 "bridge_logger.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"

#line 15 "bridge_misc.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"

#line 15 "bridge_peer.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"

#line 15 "bridge_uapi.go"

#include "wireguard_go_bridge.h"

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#if !defined(__cplusplus) || _MSVC_LANG <= 201402L
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
#include <complex>
typedef std::complex<float> GoComplex64;
typedef std::complex<double> GoComplex128;
#endif
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif

extern int32_t AllowedIpsInsert(int64_t deviceHandle, char* peerPubKeyHex, char* prefixStr);
extern int32_t AllowedIpsReplaceForPeer(int64_t deviceHandle, char* peerPubKeyHex, char* prefixes);
extern int32_t AllowedIpsRemoveByPeer(int64_t deviceHandle, char* peerPubKeyHex);
extern char* AllowedIpsGetForPeer(int64_t deviceHandle, char* peerPubKeyHex);
extern int64_t CookieCheckerCreate(void);
extern int32_t CookieCheckerInit(int64_t handle, char* pubKeyHex);
extern _Bool CookieCheckerCheckMAC1(int64_t handle, void* msg, int msgLen);
extern _Bool CookieCheckerCheckMAC2(int64_t handle, void* msg, int msgLen, void* src, int srcLen);
extern int32_t CookieCheckerCreateReply(int64_t handle, void* msg, int msgLen, uint32_t recv, void* src, int srcLen, void* out, int* outLen);
extern void CookieCheckerFree(int64_t handle);
extern int64_t CookieGeneratorCreate(void);
extern int32_t CookieGeneratorInit(int64_t handle, char* pubKeyHex);
extern int32_t CookieGeneratorAddMacs(int64_t handle, void* msg, int msgLen);
extern _Bool CookieGeneratorConsumeReply(int64_t handle, void* msg, int msgLen);
extern void CookieGeneratorFree(int64_t handle);
extern void HMAC1(void* key, int keyLen, void* in0, int in0Len, void* out);
extern void HMAC2(void* key, int keyLen, void* in0, int in0Len, void* in1, int in1Len, void* out);
extern void KDF1(void* key, int keyLen, void* input, int inputLen, void* t0);
extern void KDF2(void* key, int keyLen, void* input, int inputLen, void* t0, void* t1);
extern void KDF3(void* key, int keyLen, void* input, int inputLen, void* t0, void* t1, void* t2);
extern int Blake2sSize(void);
extern int64_t NewDevice(char* ifname, int mtu, int64_t loggerHandle);
extern int32_t DeviceClose(int64_t handle);
extern int32_t DeviceUp(int64_t handle);
extern int32_t DeviceDown(int64_t handle);
extern int32_t DeviceIpcSet(int64_t handle, char* config);
extern char* DeviceIpcGet(int64_t handle);
extern int64_t DeviceIpcSetOperation(int64_t handle, char* config);
extern int32_t DeviceBindClose(int64_t handle);
extern int32_t DeviceBindUpdate(int64_t handle);
extern int32_t DeviceBindSetMark(int64_t handle, uint32_t mark);
extern int64_t DeviceBind(int64_t handle);
extern int DeviceBatchSize(int64_t handle);
extern _Bool DeviceIsUnderLoad(int64_t handle);
extern int32_t DeviceWait(int64_t handle);
extern int32_t DeviceSetPrivateKey(int64_t handle, char* hexKey);
extern int64_t DeviceNewPeer(int64_t handle, char* pubKeyHex);
extern int64_t DeviceLookupPeer(int64_t handle, char* pubKeyHex);
extern int32_t DeviceRemovePeer(int64_t handle, char* pubKeyHex);
extern int32_t DeviceRemoveAllPeers(int64_t handle);
extern int32_t DevicePopulatePools(int64_t handle);
extern int32_t DeviceDisableRoaming(int64_t handle);
extern int32_t DeviceSendKeepalivesToPeers(int64_t handle);
extern void FreeString(char* s);
extern char* GeneratePrivateKey(void);
extern char* DerivePublicKey(char* privateKeyHex);
extern char* GeneratePresharedKey(void);
extern int32_t PrivateKeyFromHex(char* hexStr, void* out);
extern int32_t PrivateKeyFromMaybeZeroHex(char* hexStr, void* out);
extern _Bool PrivateKeyIsZero(char* keyHex);
extern _Bool PrivateKeyEquals(char* keyAHex, char* keyBHex);
extern int32_t PublicKeyFromHex(char* hexStr, void* out);
extern _Bool PublicKeyIsZero(char* keyHex);
extern _Bool PublicKeyEquals(char* keyAHex, char* keyBHex);
extern int32_t PresharedKeyFromHex(char* hexStr, void* out);
extern void SetLogCallback(WgLogCallback callback, void* context);
extern int64_t NewLogger(int level, char* prepend);
extern void LoggerFree(int64_t handle);
extern void DiscardLogf(void);
extern int64_t IpcErrorCode(int64_t errCode);
extern char* BridgeVersion(void);
extern char* WireguardGoVersion(void);
extern int ActiveDeviceCount(void);
extern int ActivePeerCount(void);
extern int32_t PeerStart(int64_t handle);
extern int32_t PeerStop(int64_t handle);
extern char* PeerString(int64_t handle);
extern void PeerFree(int64_t handle);
extern int32_t PeerSendHandshakeInitiation(int64_t handle, _Bool isRetry);
extern int32_t PeerSendHandshakeResponse(int64_t handle);
extern int32_t PeerBeginSymmetricSession(int64_t handle);
extern int32_t PeerSendKeepalive(int64_t handle);
extern int32_t PeerSendStagedPackets(int64_t handle);
extern int32_t PeerExpireCurrentKeypairs(int64_t handle);
extern int32_t PeerFlushStagedPackets(int64_t handle);
extern int32_t PeerZeroAndFlushAll(int64_t handle);
extern int32_t Run(char* ifname, int logLevel);
extern int32_t DeviceUAPIListen(int64_t deviceHandle, char* ifname);
extern int32_t DeviceUAPIClose(int64_t deviceHandle, char* ifname);
extern char* DeviceUAPISocketPath(char* ifname);

#ifdef __cplusplus
}
#endif
