name: Setup Recording Environment

on:
  workflow_dispatch:
    inputs:
      session_name:
        description: 'Session name (e.g., ghost-recording, multihop-test)'
        required: true
        type: string
        default: 'recording-session'
      ssh_public_key:
        description: 'SSH public key for accessing droplets (e.g., ssh-ed25519 AAAA... user@host)'
        required: true
        type: string

env:
  DO_REGION: fra1
  DO_SIZE: s-2vcpu-4gb-120gb-intel
  VPC_SUBNET: "10.10.0.0/16"
  DO_IMAGE: "debian-13-x64"

jobs:
  setup:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Install doctl
        uses: digitalocean/action-doctl@135ac0aa0eed4437d547c6f12c364d3006b42824 # v2
        with:
          token: ${{ secrets.DO_TOKEN }}

      - name: Install jq
        run: sudo apt-get install -y jq

      # ─────────────────────────────────────────────────────────────
      # Session & SSH Keys
      # ─────────────────────────────────────────────────────────────
      - name: Generate Session ID
        id: session
        run: |
          TIMESTAMP=$(date +%s)
          SESSION_ID="phantom-${{ inputs.session_name }}-${TIMESTAMP}"
          echo "SESSION_ID=$SESSION_ID" >> $GITHUB_OUTPUT
          echo "Session ID: $SESSION_ID"

      - name: Generate Provisioning SSH Key
        id: provision_key
        run: |
          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"

          ssh-keygen -t ed25519 -f /tmp/provision_key -N "" -q
          chmod 600 /tmp/provision_key

          KEY_JSON=$(doctl compute ssh-key import "${SESSION_ID}-provision" \
            --public-key-file /tmp/provision_key.pub \
            --output json)

          PROVISION_KEY_ID=$(echo "$KEY_JSON" | jq -r '.[0].id')
          PROVISION_KEY_FP=$(echo "$KEY_JSON" | jq -r '.[0].fingerprint')

          echo "PROVISION_KEY_ID=$PROVISION_KEY_ID" >> $GITHUB_OUTPUT
          echo "PROVISION_KEY_FP=$PROVISION_KEY_FP" >> $GITHUB_OUTPUT
          echo "Provisioning key registered: $PROVISION_KEY_FP"

      - name: Register User SSH Key
        id: user_key
        run: |
          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"

          echo "${{ inputs.ssh_public_key }}" > /tmp/user_key.pub

          KEY_JSON=$(doctl compute ssh-key import "${SESSION_ID}-user" \
            --public-key-file /tmp/user_key.pub \
            --output json)

          USER_KEY_ID=$(echo "$KEY_JSON" | jq -r '.[0].id')
          USER_KEY_FP=$(echo "$KEY_JSON" | jq -r '.[0].fingerprint')

          echo "USER_KEY_ID=$USER_KEY_ID" >> $GITHUB_OUTPUT
          echo "USER_KEY_FP=$USER_KEY_FP" >> $GITHUB_OUTPUT
          echo "User key registered: $USER_KEY_FP"

      # ─────────────────────────────────────────────────────────────
      # Create Project & VPC
      # ─────────────────────────────────────────────────────────────
      - name: Create Project
        id: project
        run: |
          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"

          PROJECT_JSON=$(doctl projects create \
            --name "$SESSION_ID" \
            --purpose "Recording session" \
            --environment "Development" \
            --output json)

          PROJECT_ID=$(echo "$PROJECT_JSON" | jq -r '.[0].id')

          echo "PROJECT_ID=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "Created project: $SESSION_ID ($PROJECT_ID)"

      - name: Create VPC
        id: vpc
        run: |
          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"

          VPC_JSON=$(doctl vpcs create \
            --name "${SESSION_ID}-vpc" \
            --region ${{ env.DO_REGION }} \
            --ip-range ${{ env.VPC_SUBNET }} \
            --output json 2>&1) || {
            echo "VPC creation failed:"
            echo "$VPC_JSON"
            exit 1
          }

          VPC_ID=$(echo "$VPC_JSON" | jq -r '.[0].id // .id // empty')

          if [ -z "$VPC_ID" ]; then
            echo "Failed to parse VPC ID from response"
            exit 1
          fi

          echo "VPC_ID=$VPC_ID" >> $GITHUB_OUTPUT
          echo "Created VPC: ${SESSION_ID}-vpc ($VPC_ID)"

      # ─────────────────────────────────────────────────────────────
      # Create Droplets
      # ─────────────────────────────────────────────────────────────
      - name: Create Droplets
        id: droplets
        run: |
          VPC_ID="${{ steps.vpc.outputs.VPC_ID }}"
          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"
          PROVISION_FP="${{ steps.provision_key.outputs.PROVISION_KEY_FP }}"
          USER_FP="${{ steps.user_key.outputs.USER_KEY_FP }}"

          echo "Creating droplets in VPC: $VPC_ID"
          echo ""

          create_droplet() {
            local name=$1
            local var_name=$2

            echo "Creating $name..."

            RESULT=$(doctl compute droplet create "${SESSION_ID}-${name}" \
              --image ${{ env.DO_IMAGE }} \
              --size ${{ env.DO_SIZE }} \
              --region ${{ env.DO_REGION }} \
              --vpc-uuid "$VPC_ID" \
              --ssh-keys "$PROVISION_FP,$USER_FP" \
              --wait \
              --output json 2>&1) || {
              echo "Failed to create $name:"
              echo "$RESULT"
              return 1
            }

            ID=$(echo "$RESULT" | jq -r '.[0].id // empty')
            if [ -z "$ID" ]; then
              echo "Failed to parse ID for $name"
              echo "Response: $RESULT"
              return 1
            fi

            echo "${var_name}=$ID" >> $GITHUB_OUTPUT
            echo "Created: $name ($ID)"
          }

          create_droplet "master" "MASTER_ID"
          create_droplet "server" "SERVER_ID"
          create_droplet "client" "CLIENT_ID"
          create_droplet "exit"   "EXIT_ID"

      # ─────────────────────────────────────────────────────────────
      # Assign Resources to Project
      # ─────────────────────────────────────────────────────────────
      - name: Assign Resources to Project
        run: |
          PROJECT_ID="${{ steps.project.outputs.PROJECT_ID }}"

          doctl projects resources assign $PROJECT_ID \
            --resource=do:droplet:${{ steps.droplets.outputs.MASTER_ID }} \
            --resource=do:droplet:${{ steps.droplets.outputs.SERVER_ID }} \
            --resource=do:droplet:${{ steps.droplets.outputs.CLIENT_ID }} \
            --resource=do:droplet:${{ steps.droplets.outputs.EXIT_ID }}

          echo "All droplets assigned to project"

      # ─────────────────────────────────────────────────────────────
      # Collect IP Addresses
      # ─────────────────────────────────────────────────────────────
      - name: Collect IP Addresses
        id: ips
        run: |
          get_ips() {
            local droplet_id=$1
            local prefix=$2

            INFO=$(doctl compute droplet get "$droplet_id" --output json)
            PUBLIC=$(echo "$INFO" | jq -r '.[0].networks.v4[] | select(.type=="public") | .ip_address')
            PRIVATE=$(echo "$INFO" | jq -r '.[0].networks.v4[] | select(.type=="private") | .ip_address')

            echo "${prefix}_PUBLIC=$PUBLIC" >> $GITHUB_OUTPUT
            echo "${prefix}_PRIVATE=$PRIVATE" >> $GITHUB_OUTPUT
            echo "$prefix: public=$PUBLIC private=$PRIVATE"
          }

          get_ips "${{ steps.droplets.outputs.MASTER_ID }}" "MASTER"
          get_ips "${{ steps.droplets.outputs.SERVER_ID }}" "SERVER"
          get_ips "${{ steps.droplets.outputs.CLIENT_ID }}" "CLIENT"
          get_ips "${{ steps.droplets.outputs.EXIT_ID }}"   "EXIT"

      # ─────────────────────────────────────────────────────────────
      # Wait for SSH Readiness
      # ─────────────────────────────────────────────────────────────
      - name: Wait for SSH Readiness
        run: |
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=5 -i /tmp/provision_key"

          wait_for_ssh() {
            local host=$1
            local name=$2
            local max_attempts=30

            echo "Waiting for $name ($host)..."
            for i in $(seq 1 $max_attempts); do
              if ssh $SSH_OPTS root@$host "echo ready" &>/dev/null; then
                echo "  $name is ready (attempt $i)"
                return 0
              fi
              sleep 10
            done
            echo "  WARN: $name may not be ready after $max_attempts attempts"
            return 1
          }

          wait_for_ssh "${{ steps.ips.outputs.MASTER_PUBLIC }}" "master"
          wait_for_ssh "${{ steps.ips.outputs.SERVER_PUBLIC }}" "server"
          wait_for_ssh "${{ steps.ips.outputs.CLIENT_PUBLIC }}" "client"
          wait_for_ssh "${{ steps.ips.outputs.EXIT_PUBLIC }}"   "exit"

      # ─────────────────────────────────────────────────────────────
      # Configure Master
      # ─────────────────────────────────────────────────────────────
      - name: Configure Master
        id: master_config
        run: |
          SSH="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key root@${{ steps.ips.outputs.MASTER_PUBLIC }}"
          SCP="scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key"

          MASTER_IP="${{ steps.ips.outputs.MASTER_PRIVATE }}"
          SERVER_IP="${{ steps.ips.outputs.SERVER_PRIVATE }}"
          CLIENT_IP="${{ steps.ips.outputs.CLIENT_PRIVATE }}"
          EXIT_IP="${{ steps.ips.outputs.EXIT_PRIVATE }}"

          # Generate SSH key pair on master
          $SSH "ssh-keygen -t ed25519 -f /root/.ssh/id_ed25519 -N '' -q"
          MASTER_PUB_KEY=$($SSH "cat /root/.ssh/id_ed25519.pub")
          echo "MASTER_PUB_KEY=$MASTER_PUB_KEY" >> $GITHUB_OUTPUT

          # Configure /etc/hosts
          $SSH "cat >> /etc/hosts << EOF

          # Phantom-WG Recording Environment
          $MASTER_IP master
          $SERVER_IP server
          $CLIENT_IP client
          $EXIT_IP exit
          EOF"

          # Configure .ssh/config
          $SSH "cat > /root/.ssh/config << EOF
          Host server
              HostName $SERVER_IP
              User root
              IdentityFile ~/.ssh/id_ed25519
              StrictHostKeyChecking no

          Host client
              HostName $CLIENT_IP
              User client
              IdentityFile ~/.ssh/id_ed25519
              StrictHostKeyChecking no

          Host exit
              HostName $EXIT_IP
              User root
              IdentityFile ~/.ssh/id_ed25519
              StrictHostKeyChecking no
          EOF"
          $SSH "chmod 600 /root/.ssh/config"

          # Install packages
          $SSH "apt-get update -qq && apt-get install -y -qq asciinema jq bc curl"

          # Deploy environment files
          $SCP tools/recording-utilities/recording_environment/master/root/runner.sh root@${{ steps.ips.outputs.MASTER_PUBLIC }}:/root/runner.sh
          $SSH "chmod +x /root/runner.sh"

          echo "Master configured"

      # ─────────────────────────────────────────────────────────────
      # Configure Server
      # ─────────────────────────────────────────────────────────────
      - name: Configure Server
        run: |
          SSH="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key root@${{ steps.ips.outputs.SERVER_PUBLIC }}"
          SCP="scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key"

          MASTER_PUB_KEY="${{ steps.master_config.outputs.MASTER_PUB_KEY }}"

          # Add master's public key for inter-server SSH
          $SSH "echo '$MASTER_PUB_KEY' >> /root/.ssh/authorized_keys"

          # Install packages
          $SSH "apt-get update -qq && apt-get install -y -qq curl jq"

          # Deploy environment files
          $SCP tools/recording-utilities/recording_environment/server/etc/motd root@${{ steps.ips.outputs.SERVER_PUBLIC }}:/etc/motd
          $SCP tools/recording-utilities/recording_environment/server/root/.bashrc root@${{ steps.ips.outputs.SERVER_PUBLIC }}:/root/.bashrc

          # Remove dynamic motd so our static motd is displayed
          $SSH "rm -rf /etc/update-motd.d/* /run/motd.dynamic 2>/dev/null; chmod -x /etc/update-motd.d/* 2>/dev/null || true"

          echo "Server configured"

      # ─────────────────────────────────────────────────────────────
      # Configure Client
      # ─────────────────────────────────────────────────────────────
      - name: Configure Client
        run: |
          SSH="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key root@${{ steps.ips.outputs.CLIENT_PUBLIC }}"
          SCP="scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key"

          MASTER_PUB_KEY="${{ steps.master_config.outputs.MASTER_PUB_KEY }}"

          # Add master's public key for root
          $SSH "echo '$MASTER_PUB_KEY' >> /root/.ssh/authorized_keys"

          # Create client user with home directory
          $SSH "useradd -m -s /bin/bash client"
          $SSH "mkdir -p /home/client/.ssh && chmod 700 /home/client/.ssh"
          $SSH "echo '$MASTER_PUB_KEY' >> /home/client/.ssh/authorized_keys"
          $SSH "chmod 600 /home/client/.ssh/authorized_keys"
          $SSH "chown -R client:client /home/client/.ssh"

          # Grant sudo for wireguard commands
          $SSH "echo 'client ALL=(ALL) NOPASSWD: /usr/bin/wg-quick, /usr/bin/wg' > /etc/sudoers.d/client-wireguard"
          $SSH "chmod 440 /etc/sudoers.d/client-wireguard"

          # Install packages
          $SSH "apt-get update -qq && apt-get install -y -qq wireguard-tools curl"

          # Deploy environment files
          $SCP tools/recording-utilities/recording_environment/client/etc/motd/motd root@${{ steps.ips.outputs.CLIENT_PUBLIC }}:/etc/motd

          # Remove dynamic motd so our static motd is displayed
          $SSH "rm -rf /etc/update-motd.d/* /run/motd.dynamic 2>/dev/null; chmod -x /etc/update-motd.d/* 2>/dev/null || true"

          echo "Client configured"

      # ─────────────────────────────────────────────────────────────
      # Configure Exit
      # ─────────────────────────────────────────────────────────────
      - name: Configure Exit
        run: |
          SSH="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key root@${{ steps.ips.outputs.EXIT_PUBLIC }}"
          SCP="scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key"

          MASTER_PUB_KEY="${{ steps.master_config.outputs.MASTER_PUB_KEY }}"

          # Add master's public key for inter-server SSH
          $SSH "echo '$MASTER_PUB_KEY' >> /root/.ssh/authorized_keys"

          # Install packages
          $SSH "apt-get update -qq && apt-get install -y -qq curl"

          # Deploy environment files
          $SCP tools/recording-utilities/recording_environment/exit/etc/motd/motd root@${{ steps.ips.outputs.EXIT_PUBLIC }}:/etc/motd

          # Remove dynamic motd so our static motd is displayed
          $SSH "rm -rf /etc/update-motd.d/* /run/motd.dynamic 2>/dev/null; chmod -x /etc/update-motd.d/* 2>/dev/null || true"

          echo "Exit configured"

      # ─────────────────────────────────────────────────────────────
      # Test Connections from Master
      # ─────────────────────────────────────────────────────────────
      - name: Test Connections from Master
        run: |
          SSH="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key root@${{ steps.ips.outputs.MASTER_PUBLIC }}"

          echo "Testing SSH connections from master via VPC..."
          echo ""

          # Initial connections - accepts host keys and verifies connectivity
          echo "Testing master → server (root)..."
          $SSH "ssh -o StrictHostKeyChecking=accept-new server 'hostname && echo OK'" || { echo "FAIL: master → server"; exit 1; }

          echo "Testing master → client (client user)..."
          $SSH "ssh -o StrictHostKeyChecking=accept-new client 'whoami && echo OK'" || { echo "FAIL: master → client"; exit 1; }

          echo "Testing master → exit (root)..."
          $SSH "ssh -o StrictHostKeyChecking=accept-new exit 'hostname && echo OK'" || { echo "FAIL: master → exit"; exit 1; }

          echo ""
          echo "All connections verified successfully"

      # ─────────────────────────────────────────────────────────────
      # Finalize Authorized Keys & Cleanup
      # ─────────────────────────────────────────────────────────────
      - name: Finalize Authorized Keys
        run: |
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/provision_key"
          USER_PUB_KEY="${{ inputs.ssh_public_key }}"
          MASTER_PUB_KEY="${{ steps.master_config.outputs.MASTER_PUB_KEY }}"

          # Master: only user key (master doesn't need its own key in authorized_keys)
          ssh $SSH_OPTS root@${{ steps.ips.outputs.MASTER_PUBLIC }} "echo '$USER_PUB_KEY' > /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys"
          echo "master authorized_keys finalized"

          # Server: user key + master key
          ssh $SSH_OPTS root@${{ steps.ips.outputs.SERVER_PUBLIC }} "printf '%s\n' '$USER_PUB_KEY' '$MASTER_PUB_KEY' > /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys"
          echo "server authorized_keys finalized"

          # Exit: user key + master key
          ssh $SSH_OPTS root@${{ steps.ips.outputs.EXIT_PUBLIC }} "printf '%s\n' '$USER_PUB_KEY' '$MASTER_PUB_KEY' > /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys"
          echo "exit authorized_keys finalized"

          # Client: both root and client user in a single SSH session
          ssh $SSH_OPTS root@${{ steps.ips.outputs.CLIENT_PUBLIC }} "\
            printf '%s\n' '$USER_PUB_KEY' '$MASTER_PUB_KEY' > /home/client/.ssh/authorized_keys && \
            chmod 600 /home/client/.ssh/authorized_keys && \
            chown client:client /home/client/.ssh/authorized_keys && \
            printf '%s\n' '$USER_PUB_KEY' '$MASTER_PUB_KEY' > /root/.ssh/authorized_keys && \
            chmod 600 /root/.ssh/authorized_keys"
          echo "client authorized_keys finalized"

          echo ""
          echo "All authorized_keys finalized - provisioning key removed from all servers"

      - name: Cleanup Provisioning Keys from DigitalOcean
        run: |
          # Remove provisioning SSH key record from DigitalOcean
          doctl compute ssh-key delete ${{ steps.provision_key.outputs.PROVISION_KEY_ID }} --force || true

          # Remove user SSH key record from DigitalOcean (keys remain in authorized_keys on droplets)
          doctl compute ssh-key delete ${{ steps.user_key.outputs.USER_KEY_ID }} --force || true

          echo "Provisioning keys cleaned up from DigitalOcean"
          echo "Access has been transferred from runner to user"

      # ─────────────────────────────────────────────────────────────
      # Display Results
      # ─────────────────────────────────────────────────────────────
      - name: Display Environment Info
        run: |
          SESSION_ID="${{ steps.session.outputs.SESSION_ID }}"

          MASTER_PUBLIC="${{ steps.ips.outputs.MASTER_PUBLIC }}"
          SERVER_PUBLIC="${{ steps.ips.outputs.SERVER_PUBLIC }}"
          CLIENT_PUBLIC="${{ steps.ips.outputs.CLIENT_PUBLIC }}"
          EXIT_PUBLIC="${{ steps.ips.outputs.EXIT_PUBLIC }}"

          MASTER_PRIVATE="${{ steps.ips.outputs.MASTER_PRIVATE }}"
          SERVER_PRIVATE="${{ steps.ips.outputs.SERVER_PRIVATE }}"
          CLIENT_PRIVATE="${{ steps.ips.outputs.CLIENT_PRIVATE }}"
          EXIT_PRIVATE="${{ steps.ips.outputs.EXIT_PRIVATE }}"

          echo ""
          echo "════════════════════════════════════════════════════════════"
          echo "  RECORDING ENVIRONMENT READY"
          echo "════════════════════════════════════════════════════════════"
          echo ""
          echo "Session:  $SESSION_ID"
          echo "Project:  ${{ steps.project.outputs.PROJECT_ID }}"
          echo "VPC:      ${{ steps.vpc.outputs.VPC_ID }}"
          echo "Region:   ${{ env.DO_REGION }}"
          echo "Image:    ${{ env.DO_IMAGE }}"
          echo "Size:     ${{ env.DO_SIZE }}"
          echo ""
          echo "────────────────────────────────────────────────────────────"
          echo "  DROPLET IP ADDRESSES"
          echo "────────────────────────────────────────────────────────────"
          echo ""
          printf "%-10s %-16s %-16s\n" "NAME" "PUBLIC" "PRIVATE"
          printf "%-10s %-16s %-16s\n" "master" "$MASTER_PUBLIC" "$MASTER_PRIVATE"
          printf "%-10s %-16s %-16s\n" "server" "$SERVER_PUBLIC" "$SERVER_PRIVATE"
          printf "%-10s %-16s %-16s\n" "client" "$CLIENT_PUBLIC" "$CLIENT_PRIVATE"
          printf "%-10s %-16s %-16s\n" "exit" "$EXIT_PUBLIC" "$EXIT_PRIVATE"
          echo ""
          echo "────────────────────────────────────────────────────────────"
          echo "  SSH ACCESS"
          echo "────────────────────────────────────────────────────────────"
          echo ""
          echo "Connect to master:"
          echo "  ssh root@${MASTER_PUBLIC}"
          echo ""
          echo "From master, reach other servers:"
          echo "  ssh server    # root@server (VPC)"
          echo "  ssh client    # client@client (VPC)"
          echo "  ssh exit      # root@exit (VPC)"
          echo ""
          echo "Direct access (with your SSH key):"
          echo "  ssh root@${SERVER_PUBLIC}"
          echo "  ssh root@${CLIENT_PUBLIC}   # or: ssh client@${CLIENT_PUBLIC}"
          echo "  ssh root@${EXIT_PUBLIC}"
          echo ""
          echo "────────────────────────────────────────────────────────────"
          echo "  CLEANUP COMMANDS"
          echo "────────────────────────────────────────────────────────────"
          echo ""
          echo "# Delete all droplets:"
          echo "doctl compute droplet delete ${SESSION_ID}-master ${SESSION_ID}-server ${SESSION_ID}-client ${SESSION_ID}-exit --force"
          echo ""
          echo "# Delete VPC:"
          echo "doctl vpcs delete ${{ steps.vpc.outputs.VPC_ID }} --force"
          echo ""
          echo "# Delete project:"
          echo "doctl projects delete ${{ steps.project.outputs.PROJECT_ID }} --force"
          echo ""
          echo "════════════════════════════════════════════════════════════"